#include <iostream>
#include <thread>
#include <mutex>
#include <queue>
#include <condition_variable>
#include <fstream>
#include <random>
#include <chrono>
#include <semaphore.h>

constexpr int MAX_THREADS = 3;
constexpr int SIMULATION_COUNT = 100;

struct SensorData {
    std::string sensorName;
    int sensorValue;
};

std::mutex mutex;
std::queue<SensorData> messageQueue;
std::condition_variable queueCondition;
sem_t threadLimitSemaphore;

void logSensorData(const SensorData& data) {
    std::string fileName = data.sensorName.substr(0, data.sensorName.find_last_of('.')) + ".log";
    std::ofstream file(fileName, std::ios::app);
    if (file.is_open()) {
        file << data.sensorValue << ", ";
        file.close();
    }
}

void handleSensorData() {
    while (true) {
        std::unique_lock<std::mutex> lock(mutex);
        queueCondition.wait(lock, [] { return !messageQueue.empty(); });

        SensorData data = messageQueue.front();
        messageQueue.pop();

        lock.unlock();
        queueCondition.notify_all();

        logSensorData(data);

        sem_post(&threadLimitSemaphore);
    }
}

void simulateAndSendData() {
    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution<int> distribution(1, 10);

    for (int i = 0; i < SIMULATION_COUNT; ++i) {
        std::this_thread::sleep_for(std::chrono::seconds(1));

        SensorData data;
        data.sensorName = "censor_monitor" + std::to_string(distribution(generator)) + ".log";
        data.sensorValue = distribution(generator);

        sem_wait(&threadLimitSemaphore);

        {
            std::unique_lock<std::mutex> lock(mutex);
            messageQueue.push(data);
            lock.unlock();
            queueCondition.notify_all();
        }
    }
}

int main() {
    sem_init(&threadLimitSemaphore, 0, MAX_THREADS);

    std::vector<std::thread> threads;

    for (int i = 0; i < MAX_THREADS; ++i) {
        threads.emplace_back(handleSensorData);
    }

    std::thread simulationThread(simulateAndSendData);

    for (auto& thread : threads) {
        thread.join();
    }

    simulationThread.join();

    sem_destroy(&threadLimitSemaphore);

    return 0;
}

#include <iostream>
#include <fstream>
#include <sstream>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/wait.h>
#include <cstring>

constexpr int MAX_FILES = 5;
constexpr int BUFFER_SIZE = 1024;
constexpr int SHARED_MEMORY_SIZE = 4096;
constexpr int PORT = 8080;

struct EmailData {
    std::string sender;
    std::string receiver;
    std::string content;
};

void processParent(const std::string& filename, int socket) {
    // Read email data from import file
    std::ifstream file(filename);
    std::string line;
    std::string sender, receiver, content;
    while (std::getline(file, line)) {
        if (line.find("From:") == 0) {
            sender = line.substr(6);
        } else if (line.find("To:") == 0) {
            receiver = line.substr(4);
        } else if (!line.empty()) {
            content += line + '\n';
        }
    }
    file.close();

    // Send "is_alive" message to process 2
    send(socket, "is_alive", strlen("is_alive"), 0);

    // Wait for response from process 2
    char buffer[BUFFER_SIZE];
    recv(socket, buffer, BUFFER_SIZE, 0);
    std::string response(buffer);
    if (response == "alive") {
        // Process 2 is still alive, save email data to shared memory
        key_t key = ftok("email_archive.csv", 65);
        int shmid = shmget(key, SHARED_MEMORY_SIZE, 0666|IPC_CREAT);
        char* sharedMemory = (char*) shmat(shmid, (void*)0, 0);

        // Write email data to shared memory
        std::stringstream ss;
        ss << sender << ";" << receiver << ";" << content << std::endl;
        std::string emailData = ss.str();
        strncpy(sharedMemory, emailData.c_str(), SHARED_MEMORY_SIZE);

        shmdt(sharedMemory);
    } else {
        // Process 2 is not alive, fork new process 2
        pid_t pid = fork();
        if (pid == 0) {
            // Child process (Process 2)
            processChild(socket);
        }
    }
}

void processChild(int socket) {
    // Create socket connection for Process 2
    int serverSocket, newSocket;
    struct sockaddr_in address;
    int addrlen = sizeof(address);

    serverSocket = socket(AF_INET, SOCK_STREAM, 0);
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    bind(serverSocket, (struct sockaddr *)&address, sizeof(address));
    listen(serverSocket, 1);

    newSocket = accept(serverSocket, (struct sockaddr *)&address, (socklen_t*)&addrlen);

    // Receive "is_alive" message from Process 1
    char buffer[BUFFER_SIZE];
    recv(newSocket, buffer, BUFFER_SIZE, 0);
    std::string message(buffer);

    if (message == "is_alive") {
        // Send "alive" response to Process 1
        send(newSocket, "alive", strlen("alive"), 0);

        // Check if shared memory has data
        key_t key = ftok("email_archive.csv", 65);
        int shmid = shmget(key, SHARED_MEMORY_SIZE, 0666);
        char* sharedMemory = (char*) shmat(shmid, (void*)0, 0);

        if (strlen(sharedMemory) > 0) {
            // Read data from shared memory and process it
            std::string emailData(sharedMemory);
            shmdt(sharedMemory);

            // Log content to summary file (email_archive.csv)
            std::ofstream file("email_archive.csv", std::ios::app);
            if (file.is_open()) {
                file << emailData;
                file.close();
            }
        }
    }

    // Receive "shutdown" message from Process 1
    recv(newSocket, buffer, BUFFER_SIZE, 0);
    std::string shutdownMessage(buffer);
    if (shutdownMessage == "shutdown") {
        // Close the connection and end Process 2
        close(newSocket);
        close(serverSocket);
        exit(0);
    }
}

int main() {
    // Create socket connection for Process 1
    int socketFd = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in serverAddress;
    serverAddress.sin_family = AF_INET;
    serverAddress.sin_port = htons(PORT);
    serverAddress.sin_addr.s_addr = inet_addr("127.0.0.1");

    if (connect(socketFd, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) < 0) {
        std::cout << "Connection Failed" << std::endl;
        return -1;
    }

    for (int i = 1; i <= MAX_FILES; ++i) {
        std::string filename = "import_file" + std::to_string(i) + ".txt";
        processParent(filename, socketFd);
    }

    // Send "shutdown" message to Process 2
    send(socketFd, "shutdown", strlen("shutdown"), 0);

    // Check if Process 2 is still alive
    char buffer[BUFFER_SIZE];
    recv(socketFd, buffer, BUFFER_SIZE, 0);
    std::string response(buffer);
    if (response != "alive") {
        // Process 2 is not alive, shutdown Process 1 as well
        std::cout << "Process 2 is not alive. Shutting down Process 1." << std::endl;
    }

    close(socketFd);

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>

#define MAX_BUFFER_SIZE 1024
#define SHARED_MEM_SIZE 4096

struct Email {
    char sender[100];
    char receiver[100];
    char content[500];
};

int main() {
    int sockfd, connfd;
    pid_t childpid;
    struct sockaddr_in servaddr, cli;

    // Socket creation
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror("Socket creation failed");
        exit(1);
    }

    // Socket binding
    memset(&servaddr, 0, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    servaddr.sin_port = htons(8080);

    if (bind(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) != 0) {
        perror("Socket binding failed");
        exit(1);
    }

    // Socket listening
    if (listen(sockfd, 5) != 0) {
        perror("Socket listening failed");
        exit(1);
    }

    // Shared memory creation
    int shmid = shm_open("email_data", O_CREAT | O_RDWR, 0666);
    if (shmid == -1) {
        perror("Shared memory creation failed");
        exit(1);
    }

    if (ftruncate(shmid, SHARED_MEM_SIZE) == -1) {
        perror("Shared memory truncate failed");
        exit(1);
    }

    char* sharedMem = mmap(NULL, SHARED_MEM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shmid, 0);
    if (sharedMem == MAP_FAILED) {
        perror("Shared memory mapping failed");
        exit(1);
    }

    // Fork a child process
    childpid = fork();
    if (childpid == -1) {
        perror("Fork failed");
        exit(1);
    } else if (childpid == 0) {
        // Child process (Process 2)
        close(sockfd);

        while (1) {
            // Wait for "is_alive" message
            recv(connfd, buffer, sizeof(buffer), 0);

            // Send "alive" response
            send(connfd, "alive", sizeof("alive"), 0);

            // Check if shared memory has data
            if (strlen(sharedMem) > 0) {
                // Log content to email_archive.csv
                FILE* file = fopen("email_archive.csv", "a");
                if (file == NULL) {
                    perror("Error opening email_archive.csv");
                    exit(1);
                }
                fprintf(file, "%s\n", sharedMem);
                fclose(file);

                // Clear shared memory
                memset(sharedMem, 0, SHARED_MEM_SIZE);
            }

            // Check if received "shutdown" message
            if (strcmp(buffer, "shutdown") == 0) {
                break;
            }
        }

        exit(0);
    } else {
        // Parent process (Process 1)
        close(connfd);

        // Read and process import files
        FILE* file;
        char line[MAX_BUFFER_SIZE];
        char emailData[MAX_BUFFER_SIZE];

        file = fopen("file1.txt", "r");
        // ...

        while (fgets(line, sizeof(line), file)) {
            // Process email data and save to shared memory
            // ...

            // Send "is_alive" message to child process
            send(connfd, "is_alive", sizeof("is_alive"), 0);

            // Wait for response
            recv(connfd, buffer, sizeof(buffer), 0);

            // Check if child process is alive
            if (strcmp(buffer, "alive") == 0) {
                // Save email data to shared memory
                strcpy(sharedMem, emailData);
            } else {
                // Fork new child process
                childpid = fork();
                if (childpid == -1) {
                    perror("Fork failed");
                    exit(1);
                } else if (childpid == 0) {
                    // Child process (Process 2)
                    // ...
                }
            }

            // ...
        }

        // Send "shutdown" message to child process
        send(connfd, "shutdown", sizeof("shutdown"), 0);

        // Wait for child process to terminate
        wait(NULL);

        // Close the socket
        close(sockfd);

        // ...
    }

    return 0;
}
